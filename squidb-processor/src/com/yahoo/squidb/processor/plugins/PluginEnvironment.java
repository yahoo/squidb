/*
 * Copyright 2015, Yahoo Inc.
 * Copyrights licensed under the Apache 2.0 License.
 * See the accompanying LICENSE file for terms.
 */
package com.yahoo.squidb.processor.plugins;

import com.yahoo.aptutils.utils.AptUtils;
import com.yahoo.squidb.processor.data.ModelSpec;
import com.yahoo.squidb.processor.plugins.defaults.AndroidModelPlugin;
import com.yahoo.squidb.processor.plugins.defaults.ConstantCopyingPlugin;
import com.yahoo.squidb.processor.plugins.defaults.ConstructorPlugin;
import com.yahoo.squidb.processor.plugins.defaults.ImplementsPlugin;
import com.yahoo.squidb.processor.plugins.defaults.JavadocPlugin;
import com.yahoo.squidb.processor.plugins.defaults.ModelMethodPlugin;
import com.yahoo.squidb.processor.plugins.defaults.properties.EnumPluginBundle;
import com.yahoo.squidb.processor.plugins.defaults.properties.InheritedModelSpecFieldPlugin;
import com.yahoo.squidb.processor.plugins.defaults.properties.TableModelSpecFieldPlugin;
import com.yahoo.squidb.processor.plugins.defaults.properties.ViewModelSpecFieldPlugin;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.processing.ProcessingEnvironment;
import javax.tools.Diagnostic;

/**
 * This class maintains a list of known/enabled {@link Plugin} classes. Plugins available by default include
 * {@link ConstructorPlugin} for generating model constructors, {@link ImplementsPlugin} for allowing models to
 * implement interfaces, {@link ModelMethodPlugin} for copying methods from the model spec to the model, and the three
 * property generator plugins ({@link TableModelSpecFieldPlugin}, {@link ViewModelSpecFieldPlugin}, and
 * {@link InheritedModelSpecFieldPlugin}).
 * <p>
 * This class also manages options for the default plugins--the default plugins for constructors, interfaces, and model
 * methods can all be disabled using an option. Other options allow disabling default content values, disabling the
 * convenience getters and setters that accompany each property, and preferring user-defined plugins to the default
 * plugins. Options are passed as a comma-separated list of strings to the processor using the key "squidbOptions".
 * <p>
 * All Plugin instances have access to the instance of PluginEnvironment that created them, and can call
 * {@link #hasOption(String)} or {@link #getEnvOptions()} to read any custom options specific to that plugin.
 */
public class PluginEnvironment {

    public static final String PLUGINS_KEY = "squidbPlugins";
    public static final String OPTIONS_KEY = "squidbOptions";
    private static final String SEPARATOR = ",";

    private final AptUtils utils;
    private final Map<String, String> envOptions;
    private final Set<String> squidbOptions;
    private List<Class<? extends Plugin>> highPriorityPlugins = new ArrayList<>();
    private List<Class<? extends Plugin>> normalPriorityPlugins = new ArrayList<>();
    private List<Class<? extends Plugin>> lowPriorityPlugins = new ArrayList<>();

    private boolean checkHandledOptions = true;

    public enum PluginPriority {
        LOW,
        NORMAL,
        HIGH
    }

    /**
     * Option for disabling the default constructors generated in each model class
     */
    public static final String OPTIONS_DISABLE_DEFAULT_CONSTRUCTORS = "disableDefaultConstructors";

    /**
     * Option for disabling default processing of the {@link com.yahoo.squidb.annotations.Implements} annotation for
     * declaring that models implement interfaces
     */
    public static final String OPTIONS_DISABLE_DEFAULT_IMPLEMENTS_HANDLING = "disableImplements";

    /**
     * Option for disabling the default copying of static methods and model methods from the spec to the model class
     */
    public static final String OPTIONS_DISABLE_DEFAULT_METHOD_HANDLING = "disableModelMethod";

    /**
     * Option for disabling the default copying of public static final fields as constants to the generated model
     */
    public static final String OPTIONS_DISABLE_DEFAULT_CONSTANT_COPYING = "disableConstantCopying";

    /**
     * Option for disabling the in-memory default content values used as for fallback values in empty models
     */
    public static final String OPTIONS_DISABLE_DEFAULT_VALUES = "disableDefaultValues";

    /**
     * Option for disabling the convenience getters and setters generated by default with each property
     */
    public static final String OPTIONS_DISABLE_DEFAULT_GETTERS_AND_SETTERS = "disableGettersAndSetters";

    /**
     * Option for disabling javadoc copying
     */
    public static final String OPTIONS_DISABLE_JAVADOC_COPYING = "disableJavadoc";

    /**
     * Option for disabling the default support for Enum properties
     */
    public static final String OPTIONS_DISABLE_ENUM_PROPERTIES = "disableEnumProperties";

    /**
     * Option for generating models that have Android-specific features
     */
    public static final String OPTIONS_GENERATE_ANDROID_MODELS = "androidModels";

    /**
     * @param utils annotation processing utilities class
     * @param envOptions map of annotation processing options obtained from {@link ProcessingEnvironment#getOptions()}
     */
    public PluginEnvironment(AptUtils utils, Map<String, String> envOptions) {
        this.utils = utils;
        this.envOptions = Collections.unmodifiableMap(envOptions == null ? new HashMap<String, String>() : envOptions);
        this.squidbOptions = parseOptions();
        initializeDefaultPlugins();
        initializePluginsFromEnvironment();
    }

    private Set<String> parseOptions() {
        Set<String> result = new HashSet<>();
        String optionsString = envOptions.get(OPTIONS_KEY);
        if (!AptUtils.isEmpty(optionsString)) {
            String[] allOptions = optionsString.split(SEPARATOR);
            Collections.addAll(result, allOptions);
        }
        return result;
    }

    private void initializeDefaultPlugins() {
        if (hasOption(OPTIONS_GENERATE_ANDROID_MODELS)) {
            normalPriorityPlugins.add(AndroidModelPlugin.class);
        }

        if (!hasOption(OPTIONS_DISABLE_DEFAULT_CONSTRUCTORS)) {
            normalPriorityPlugins.add(ConstructorPlugin.class);
        }
        if (!hasOption(OPTIONS_DISABLE_DEFAULT_IMPLEMENTS_HANDLING)) {
            normalPriorityPlugins.add(ImplementsPlugin.class);
        }
        if (!hasOption(OPTIONS_DISABLE_DEFAULT_METHOD_HANDLING)) {
            normalPriorityPlugins.add(ModelMethodPlugin.class);
        }
        if (!hasOption(OPTIONS_DISABLE_JAVADOC_COPYING)) {
            normalPriorityPlugins.add(JavadocPlugin.class);
        }

        // Can't disable these, but they can be overridden by user plugins with high priority
        normalPriorityPlugins.add(TableModelSpecFieldPlugin.class);
        normalPriorityPlugins.add(ViewModelSpecFieldPlugin.class);
        normalPriorityPlugins.add(InheritedModelSpecFieldPlugin.class);

        if (!hasOption(OPTIONS_DISABLE_ENUM_PROPERTIES)) {
            normalPriorityPlugins.add(EnumPluginBundle.class);
        }

        if (!hasOption(OPTIONS_DISABLE_DEFAULT_CONSTANT_COPYING)) {
            // This plugin claims any public static final fields not handled by the other plugins and copies them to
            // the generated model. Set to low priority so that by default user plugins can have first pass at
            // handing such fields.
            lowPriorityPlugins.add(ConstantCopyingPlugin.class);
        }
    }

    private void initializePluginsFromEnvironment() {
        String pluginsString = envOptions.get(PLUGINS_KEY);
        if (!AptUtils.isEmpty(pluginsString)) {
            String[] allPlugins = pluginsString.split(SEPARATOR);
            for (String plugin : allPlugins) {
                processPlugin(plugin);
            }
        }
    }

    @SuppressWarnings("unchecked")
    private void processPlugin(String pluginName) {
        try {
            PluginPriority priority = PluginPriority.NORMAL;
            if (pluginName.contains(":")) {
                String[] nameAndPriority = pluginName.split(":");
                if (nameAndPriority.length != 2) {
                    utils.getMessager().printMessage(Diagnostic.Kind.ERROR,
                            "Error parsing plugin and priority " + pluginName);
                } else {
                    pluginName = nameAndPriority[0];
                    String priorityString = nameAndPriority[1];
                    priority = PluginPriority.valueOf(priorityString.toUpperCase());
                    if (priority == null) {
                        utils.getMessager().printMessage(Diagnostic.Kind.WARNING, "Unrecognized priority string " +
                                priorityString + " for plugin " + pluginName + ", defaulting to 'normal'. Should be " +
                                "one of '" + PluginPriority.HIGH + "', " + "'" + PluginPriority.NORMAL + "', or '" +
                                PluginPriority.LOW + "'.");
                        priority = PluginPriority.NORMAL;
                    }
                }
            }
            Class<?> pluginClass = Class.forName(pluginName);
            if (Plugin.class.isAssignableFrom(pluginClass)) {
                addPlugin((Class<? extends Plugin>) pluginClass, priority);
            } else {
                utils.getMessager().printMessage(Diagnostic.Kind.WARNING,
                        "Plugin " + pluginName + " is not a subclass of Plugin");
            }
        } catch (Exception e) {
            utils.getMessager().printMessage(Diagnostic.Kind.WARNING, "Unable to instantiate plugin " + pluginName +
                    ", reason: " + e);
        }
    }

    /**
     * @param option the option to check
     * @return true if the option is set, false otherwise
     */
    public boolean hasOption(String option) {
        return squidbOptions.contains(option);
    }

    /**
     * @return envOptions map of annotation processing options obtained from {@link ProcessingEnvironment#getOptions()}.
     * Plugins may access this map to check for their own custom options.
     */
    public Map<String, String> getEnvOptions() {
        return envOptions;
    }

    /**
     * @return an AptUtils instance that provides useful annotation processing utility methods
     */
    public AptUtils getUtils() {
        return utils;
    }

    /**
     * Add a {@link Plugin} class to the list of known plugins
     *
     * @param plugin the plugin class
     * @param priority the priority to give the plugin
     */
    public void addPlugin(Class<? extends Plugin> plugin, PluginPriority priority) {
        switch (priority) {
            case LOW:
                lowPriorityPlugins.add(plugin);
                break;
            case HIGH:
                highPriorityPlugins.add(plugin);
                break;
            case NORMAL:
            default:
                normalPriorityPlugins.add(plugin);
                break;
        }
    }

    /**
     * @param modelSpec the model spec the Plugins will be instantiated for
     * @return a new {@link PluginBundle} containing Plugins initialized to handle the given model spec
     */
    public PluginBundle getPluginBundleForModelSpec(ModelSpec<?> modelSpec) {
        List<Plugin> plugins = new ArrayList<>();
        accumulatePlugins(plugins, highPriorityPlugins, modelSpec);
        accumulatePlugins(plugins, normalPriorityPlugins, modelSpec);
        accumulatePlugins(plugins, lowPriorityPlugins, modelSpec);

        if (checkHandledOptions) {
            checkHandledOptions(plugins);
            checkHandledOptions = false;
        }
        return new PluginBundle(modelSpec, this, plugins);
    }

    private void accumulatePlugins(List<Plugin> accumulator, List<Class<? extends Plugin>> pluginList,
            ModelSpec<?> modelSpec) {
        for (Class<? extends Plugin> plugin : pluginList) {
            try {
                accumulator.add(plugin.getConstructor(ModelSpec.class, PluginEnvironment.class)
                        .newInstance(modelSpec, this));
            } catch (Exception e) {
                utils.getMessager().printMessage(Diagnostic.Kind.WARNING,
                        "Unable to instantiate plugin " + plugin + ", reason: " + e);
            }
        }
    }

    private void checkHandledOptions(List<Plugin> plugins) {
        Set<String> supportedOptions = new HashSet<>();
        supportedOptions.add(OPTIONS_DISABLE_DEFAULT_CONSTANT_COPYING);
        supportedOptions.add(OPTIONS_DISABLE_DEFAULT_CONSTRUCTORS);
        supportedOptions.add(OPTIONS_DISABLE_DEFAULT_GETTERS_AND_SETTERS);
        supportedOptions.add(OPTIONS_DISABLE_DEFAULT_IMPLEMENTS_HANDLING);
        supportedOptions.add(OPTIONS_DISABLE_DEFAULT_METHOD_HANDLING);
        supportedOptions.add(OPTIONS_DISABLE_DEFAULT_VALUES);
        supportedOptions.add(OPTIONS_DISABLE_ENUM_PROPERTIES);
        supportedOptions.add(OPTIONS_DISABLE_JAVADOC_COPYING);
        supportedOptions.add(OPTIONS_GENERATE_ANDROID_MODELS);

        for (Plugin plugin : plugins) {
            List<String> pluginOpts = plugin.getSupportedOptions();
            if (pluginOpts != null) {
                supportedOptions.addAll(pluginOpts);
            }
        }
        reportUnusedOptions(supportedOptions);
    }

    private void reportUnusedOptions(Set<String> supportedOptions) {
        StringBuilder builder = null;
        for (String s : squidbOptions) {
            if (supportedOptions.contains(s)) {
                continue;
            }
            if (builder == null) {
                builder = new StringBuilder("These SquiDB plugin options appear to be unused by any plugin: ");
            } else {
                builder.append(", ");
            }
            builder.append(s);
        }
        if (builder != null) {
            utils.getMessager().printMessage(Diagnostic.Kind.WARNING, builder.toString());
        }
    }
}
